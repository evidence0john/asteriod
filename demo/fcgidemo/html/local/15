哈哈哈哈换行
<meta charset="UTF-8">
<style type="text/css">
.S0 {
	color: #808080;
	font-size: 10pt;
}
.S1 {
	font-family: 'Bitstream Vera Serif';
	color: #007F00;
	font-size: 9pt;
}
.S2 {
	font-family: 'Bitstream Vera Serif';
	color: #007F00;
	font-size: 9pt;
}
.S5 {
	font-weight: bold;
	color: #00007F;
	font-size: 10pt;
}
.S4 {
	color: #007F7F;
	font-size: 10pt;
}
.S6 {
	color: #7F007F;
	font-size: 10pt;
}
.S10 {
	font-weight: bold;
	color: #000000;
	font-size: 10pt;
}
span {
	font-family: 'Bitstream Vera Sans';
	color: #000000;
	font-size: 9pt;
}
</style>

<p>简单的说明 lbrdb - 2017-01-10</p>

<p>lbrdb 并不是专门作为数据库使用而设计的。2015 年时，因为我在写一个 NLP 的程序，在其中使用了一些数据表，后来从中抽取一些代码，作出一定的修改，成为现在的 lbrdb_model 。这只是一个数据模型，你可以直接在此模型的基础上构造新的数据结构，设计更复杂的数据库。在2016 年时，通过独立出来的 lbrdb ，我做了几个简单的例子，比如说 NLP 的关键字筛选工具 lsk ，或者一个简单的 web 应用 PHP chat 。也可以加以扩展使用 lbrdb 作为 blog 或者 BBS 应用的数据库。目前已经为 lbrdb_model 提供了一些简单的工具和扩展。lbrdb_model 的代码使用 ANSI C 编写，可以在任何 32 位以上计算机上编译使用，如果在16位系统上使用一些操作可能是不兼容的。兼容 Windows，Linux 等操作系统，事实上，即使没有操作系统，仍然能够编译和使用 lbrdb_model ，不过如果需要使用文件操作，你需要至少在你的平台上移植文件系统。</p>

<p>因为最初的设计，lbrdb 的应用是比较特殊的，所以代码中存在很多不寻常的操作。例如 compact 表， hash_di32 ，他们事实上就是为了之前 NLP 程序所设计的特殊数据模型。在多数常规的应用中应该不会使用。block 表则是比较常规的实现方式，其中提供了 quick_hash 的哈希方式也是有一些特殊用法的。关于 bug 的问题，因为一些个人原因，并没有很好的处理，大多数函数的实现拥有不错的效率，在此提及一个问题，提供了一个排序函数，使用了 shell sort 的算法实现，这个是某个特殊的约定，你可以把它替换成 quick sort 或者其他更高效的算法。</p>
<p>lbrdb_model 作为基本模块，原则上不提供有针对性的优化和扩展，只提供基本工具和实现的参考。</p>
<p>首先讲 lbrdb 中的 block 模式。这就是一个简单的线性表。表内有两个必要部分，record 和 reflection，ID 是隐含约定的。每条 record 都有与之对应的 reflection 。</p>

<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>01</td><td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>02</td><td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>

<p>可以使用以下函数创建一个 block 表：</p>

<p><em>LBRDB LBRDB_new_database_blockdb(unsigned int blen, unsigned int rf_block,
				 unsigned int nrecord);</em></p>

<p>你需要给出参数 blen ，block 的长度，也就是表中一个 record 的长度；rf_block，是 reflection 的长度；nrecord 设置表中最多能够容纳多少条记录，ID 合法的最大值就是 nrecord - 1。如果在初始化时把 blen 或者 rf_block 设置为 0，将使  record 或 reflection 无效，nreocrd 为 0 时，表是空的。通过分析内存结构，所有的 record 和 reflection 分别在两段连续的内存中，因此，如果不将表卸载，一旦创建了表，它的物理结构是不可调整的，当然，如果你采取一些特殊的算法，可以构造能够动态调整的表，那么它需要由多个表共同实现，在此不讨论。</p>

<p>建立了一张表后，能够使用下面的函数进行操作：</p>
<p>获取 record ，reflection 的指针</p>
<div style="background:#CCC;">
<span>
<span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>LBRDB_get_mem_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><br />
<span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>LBRDB_get_reflection<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><br />
</span>
</div>

<p>你可以使用任何方式操作内存，写入字符串或者二进制数据都是可以的，例如：</p>

<div style="background:#CCC;">
<span><span class="S10">...</span><br />
LBRDB<span class="S0"> </span>lbrdb<span class="S0"> </span><span class="S10">=</span><span class="S0"> </span>LBRDB_new_database_blockdb<span class="S10">(</span><span class="S4">128</span><span class="S10">,</span><span class="S0"> </span><span class="S4">4</span><span class="S10">,</span><span class="S0"> </span><span class="S4">100</span><span class="S10">);</span><br />
sprintf<span class="S10">(</span>LBRDB_get_mem_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"hello world"</span><span class="S10">);</span><br />
sprintf<span class="S10">(</span>LBRDB_get_reflection<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"%d"</span><span class="S10">,</span><span class="S0"> </span><span class="S4">0xff00ee11</span><span class="S10">);</span><br />
strcpy<span class="S10">(</span>LBRDB_get_mem_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">1</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"copy string"</span><span class="S10">);</span></span>
</div>

<p>上述代码段创建了一个 record 长度为 128，reflection 长度为 4 ，容量为 100 的 block 表。习惯上使用 record 保存主要记录，reflection 保存其他信息，多数情况下我习惯将 reflection 设为 4 ，是因为我习惯在 reflection 中保存 32 位指针，事实上 reflection 的使用是自由的，函数库中提供了一些用法保留自之前其他程序中的做法。LBRDB_get_mem_record 和 LBRDB_get_reflection 都要求两个参数，使用 LBRDB* 指向一个已经存在的表，eidc 提供操作目标的 ID 。因为并没有对数据类型作出要求，理论上你可以在内存不溢出的情况下使用任何方式操作记录。如果需要检查边界来避免溢出，record 和 reflection 的长度通过访问 LBRDB::blen 和 LBRDB::rf_block 获得。执行上述代码段后，表内数据情况如下：</p>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>hello world</td><td>0xff00ee11</td>
</tr>
<tr>
<td>01</td><td>copy string</td><td></td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>
<p><em>*ID 0 的 reflection 是 16 进制数 0xff00ee11 在此为了方便表达用字符串写出</em></p>
<p>为了避免直接操作指针，提供一些简单的读写操作：</p>
<div style="background:#CCC;">
<span>
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_reflection<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_mem_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_mem_record_bin<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>length<span class="S10">);</span><br />
<span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_write_mem<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>length<span class="S10">);</span><br />
</span>
</div>
<p>通过 remove_LBRDB_RECORD 可以删除一个记录，LBRDB_swap_blockdb_record将任意两个记录交换位置，成功则返回 0 ，否则返回非 0 状态值。不合法的 ID 或者不适当的数据表会导致操作失败返回非 0 值。</p>
<div style="background:#CCC;">
<span><span class="S5">char</span><span class="S0"> </span>remove_LBRDB_RECORD<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><span class="S0">&nbsp; &nbsp; &nbsp;</span><span class="S2">//remove record only for blockdb</span><br /><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_swap_blockdb_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc0<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc1<span class="S10">);</span><br />
</span>
</div>
<p>在上例的基础下继续执行一下两行代码：</p>
<div style="background:#CCC;">
<span><span class="S10">...</span><br />
LBRDB_swap_blockdb_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">,</span><span class="S0"> </span><span class="S4">1</span><span class="S10">);</span><br />
remove_LBRDB_RECORD<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">);</span></span>
</div>
</br>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td></td><td></td>
</tr>
<tr>
<td>01</td><td>hello world</td><td>0xff00ee11</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>
<p>首先交换表 lbrdb 中 ID 是 0 和 1 的两个记录，之后删除 ID 是 0 的记录。注意，LBRDB_swap_blockdb_record 是实实在在的通过操作内存交换了两个记录，而不是操作指针或者重新映射的方式，因此你可以直接利用此函数对表进行排序操作。remove_LBRDB_RECORD 的删除操作是不可回溯的，会清空记录的所有内容(即将内存重置为 0)。两个函数都只能用于 block 表，ID 在初始化时设置的表的容量范围内都是合法的，无论是交换两个记录还是删除某个记录，函数都不检查记录是否是空的，这么做并无不妥指出，事实上，记录如果全为二进制数据 0 也是有意义的。</p>
<p>除此之外，lbrdb_model 的库中还提供了一些其他基本的操作，和一些效率不高的搜索和排序操作，而在实际应用时根据具体情况进行扩展和优化。</p>

<p>一般情况下，一个表只提供了 record 和 reflection 两个数据段，实际情况下，数据可能拥有比较复杂的属性，你可以对 record 或者 reflection 的内部结构进行划分实现，也可以向下面这样，多个 block 表相关联实现，lbrdb0 和 lbrdb1 共用记录 ID 并不会造成额外开支，以后我们分析数据结构会知道 ID 实际上是隐含的，不占内存。</p>

<table border="1">
<tr>
<td>lbrdb0</td><td>lbrdb1</td>
</tr>
<tr><td>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>01</td><td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>02</td><td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table></td>
<td><table border="1">
<tr>
<td>record</td><td>reflection</td>
</tr>
<tr>
<td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td>
</tr>
</table>
</td>
</tr>
</table>
<p>谈一下导入和导出表的问题。关于对整个数据表的操作有以下几个基本函数：</p>
<div style="background:#CCC;">
<span>
<span><span class="S5">void</span><span class="S0"> </span>LBRDB_set_head<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
LBRDB<span class="S0"> </span>LBRDB_clone<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_delete<span class="S10">(</span>LBRDB<span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_export<span class="S10">(</span>LBRDB<span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_import<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>filename<span class="S10">);</span></span>
</div>
</span>
<p>LBRDB_set_head 用来命名和重命名一个已经存在的数据表，如果要导出数据表，必须事先给数据表命名。LBRDB_clone ，复制一个已经存在的表，将返回一个新的数据表，你需要有个容器存储复制的数据表，例如<em> LBRDB clone = LBRDB_colne(&lbrdb); </em>，能够得到一个与“lbrdb”相同的复制品“clone”。LBRDB_delete 能够销毁一个已经存在的表，删除数据并且释放内存。LBRDB_export 导出一个表到当前路径，将以表的名字创建新新的目录，并将表导出为 3 个文件：“info”，“memory_pool”，“reflection”。LBRDB_import 则用来导入一个数据表，需要提供参数“filename”，是导入保存数据表导出文件的目录的名字，也是导入数据表的名字，特别需要注意，为了避免内存泄漏 LBRDB_import 的导入对象应该是一个未初始化的空表，如果想要合并数据到已经有数据的表中，不能使用 LBRDB_import 方法，需要其他的实现方式，在此暂不讨论。 </p>
<p>最后，关于如何使用 lbrdb 的问题作出补充说明，你可以编译 lbrdb_model 为动态链接库调用，也可以将 lbrdb_model 直接编译到你的项目中，如果单独把 lbrdb 作为外部数据库访问，需要使用 lbrdb 的扩展代码，这些代码单独列出，不在 lbrdb_model 中，可以使用操作系统管理的共享内存(shared memory)方式或者程序代理使用 socket 进行连接访问。</p>










<meta charset="UTF-8">
<style type="text/css">
.S0 {
	color: #808080;
	font-size: 10pt;
}
.S1 {
	font-family: 'Bitstream Vera Serif';
	color: #007F00;
	font-size: 9pt;
}
.S2 {
	font-family: 'Bitstream Vera Serif';
	color: #007F00;
	font-size: 9pt;
}
.S5 {
	font-weight: bold;
	color: #00007F;
	font-size: 10pt;
}
.S4 {
	color: #007F7F;
	font-size: 10pt;
}
.S6 {
	color: #7F007F;
	font-size: 10pt;
}
.S10 {
	font-weight: bold;
	color: #000000;
	font-size: 10pt;
}
span {
	font-family: 'Bitstream Vera Sans';
	color: #000000;
	font-size: 9pt;
}
</style>

<p>简单的说明 lbrdb - 2017-01-10</p>

<p>lbrdb 并不是专门作为数据库使用而设计的。2015 年时，因为我在写一个 NLP 的程序，在其中使用了一些数据表，后来从中抽取一些代码，作出一定的修改，成为现在的 lbrdb_model 。这只是一个数据模型，你可以直接在此模型的基础上构造新的数据结构，设计更复杂的数据库。在2016 年时，通过独立出来的 lbrdb ，我做了几个简单的例子，比如说 NLP 的关键字筛选工具 lsk ，或者一个简单的 web 应用 PHP chat 。也可以加以扩展使用 lbrdb 作为 blog 或者 BBS 应用的数据库。目前已经为 lbrdb_model 提供了一些简单的工具和扩展。lbrdb_model 的代码使用 ANSI C 编写，可以在任何 32 位以上计算机上编译使用，如果在16位系统上使用一些操作可能是不兼容的。兼容 Windows，Linux 等操作系统，事实上，即使没有操作系统，仍然能够编译和使用 lbrdb_model ，不过如果需要使用文件操作，你需要至少在你的平台上移植文件系统。</p>

<p>因为最初的设计，lbrdb 的应用是比较特殊的，所以代码中存在很多不寻常的操作。例如 compact 表， hash_di32 ，他们事实上就是为了之前 NLP 程序所设计的特殊数据模型。在多数常规的应用中应该不会使用。block 表则是比较常规的实现方式，其中提供了 quick_hash 的哈希方式也是有一些特殊用法的。关于 bug 的问题，因为一些个人原因，并没有很好的处理，大多数函数的实现拥有不错的效率，在此提及一个问题，提供了一个排序函数，使用了 shell sort 的算法实现，这个是某个特殊的约定，你可以把它替换成 quick sort 或者其他更高效的算法。</p>
<p>lbrdb_model 作为基本模块，原则上不提供有针对性的优化和扩展，只提供基本工具和实现的参考。</p>
<p>首先讲 lbrdb 中的 block 模式。这就是一个简单的线性表。表内有两个必要部分，record 和 reflection，ID 是隐含约定的。每条 record 都有与之对应的 reflection 。</p>

<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>01</td><td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>02</td><td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>

<p>可以使用以下函数创建一个 block 表：</p>

<p><em>LBRDB LBRDB_new_database_blockdb(unsigned int blen, unsigned int rf_block,
				 unsigned int nrecord);</em></p>

<p>你需要给出参数 blen ，block 的长度，也就是表中一个 record 的长度；rf_block，是 reflection 的长度；nrecord 设置表中最多能够容纳多少条记录，ID 合法的最大值就是 nrecord - 1。如果在初始化时把 blen 或者 rf_block 设置为 0，将使  record 或 reflection 无效，nreocrd 为 0 时，表是空的。通过分析内存结构，所有的 record 和 reflection 分别在两段连续的内存中，因此，如果不将表卸载，一旦创建了表，它的物理结构是不可调整的，当然，如果你采取一些特殊的算法，可以构造能够动态调整的表，那么它需要由多个表共同实现，在此不讨论。</p>

<p>建立了一张表后，能够使用下面的函数进行操作：</p>
<p>获取 record ，reflection 的指针</p>
<div style="background:#CCC;">
<span>
<span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>LBRDB_get_mem_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><br />
<span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>LBRDB_get_reflection<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><br />
</span>
</div>

<p>你可以使用任何方式操作内存，写入字符串或者二进制数据都是可以的，例如：</p>

<div style="background:#CCC;">
<span><span class="S10">...</span><br />
LBRDB<span class="S0"> </span>lbrdb<span class="S0"> </span><span class="S10">=</span><span class="S0"> </span>LBRDB_new_database_blockdb<span class="S10">(</span><span class="S4">128</span><span class="S10">,</span><span class="S0"> </span><span class="S4">4</span><span class="S10">,</span><span class="S0"> </span><span class="S4">100</span><span class="S10">);</span><br />
sprintf<span class="S10">(</span>LBRDB_get_mem_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"hello world"</span><span class="S10">);</span><br />
sprintf<span class="S10">(</span>LBRDB_get_reflection<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"%d"</span><span class="S10">,</span><span class="S0"> </span><span class="S4">0xff00ee11</span><span class="S10">);</span><br />
strcpy<span class="S10">(</span>LBRDB_get_mem_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">1</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"copy string"</span><span class="S10">);</span></span>
</div>

<p>上述代码段创建了一个 record 长度为 128，reflection 长度为 4 ，容量为 100 的 block 表。习惯上使用 record 保存主要记录，reflection 保存其他信息，多数情况下我习惯将 reflection 设为 4 ，是因为我习惯在 reflection 中保存 32 位指针，事实上 reflection 的使用是自由的，函数库中提供了一些用法保留自之前其他程序中的做法。LBRDB_get_mem_record 和 LBRDB_get_reflection 都要求两个参数，使用 LBRDB* 指向一个已经存在的表，eidc 提供操作目标的 ID 。因为并没有对数据类型作出要求，理论上你可以在内存不溢出的情况下使用任何方式操作记录。如果需要检查边界来避免溢出，record 和 reflection 的长度通过访问 LBRDB::blen 和 LBRDB::rf_block 获得。执行上述代码段后，表内数据情况如下：</p>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>hello world</td><td>0xff00ee11</td>
</tr>
<tr>
<td>01</td><td>copy string</td><td></td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>
<p><em>*ID 0 的 reflection 是 16 进制数 0xff00ee11 在此为了方便表达用字符串写出</em></p>
<p>为了避免直接操作指针，提供一些简单的读写操作：</p>
<div style="background:#CCC;">
<span>
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_reflection<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_mem_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_mem_record_bin<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>length<span class="S10">);</span><br />
<span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_write_mem<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>length<span class="S10">);</span><br />
</span>
</div>
<p>通过 remove_LBRDB_RECORD 可以删除一个记录，LBRDB_swap_blockdb_record将任意两个记录交换位置，成功则返回 0 ，否则返回非 0 状态值。不合法的 ID 或者不适当的数据表会导致操作失败返回非 0 值。</p>
<div style="background:#CCC;">
<span><span class="S5">char</span><span class="S0"> </span>remove_LBRDB_RECORD<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><span class="S0">&nbsp; &nbsp; &nbsp;</span><span class="S2">//remove record only for blockdb</span><br /><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_swap_blockdb_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc0<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc1<span class="S10">);</span><br />
</span>
</div>
<p>在上例的基础下继续执行一下两行代码：</p>
<div style="background:#CCC;">
<span><span class="S10">...</span><br />
LBRDB_swap_blockdb_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">,</span><span class="S0"> </span><span class="S4">1</span><span class="S10">);</span><br />
remove_LBRDB_RECORD<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">);</span></span>
</div>
</br>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td></td><td></td>
</tr>
<tr>
<td>01</td><td>hello world</td><td>0xff00ee11</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>
<p>首先交换表 lbrdb 中 ID 是 0 和 1 的两个记录，之后删除 ID 是 0 的记录。注意，LBRDB_swap_blockdb_record 是实实在在的通过操作内存交换了两个记录，而不是操作指针或者重新映射的方式，因此你可以直接利用此函数对表进行排序操作。remove_LBRDB_RECORD 的删除操作是不可回溯的，会清空记录的所有内容(即将内存重置为 0)。两个函数都只能用于 block 表，ID 在初始化时设置的表的容量范围内都是合法的，无论是交换两个记录还是删除某个记录，函数都不检查记录是否是空的，这么做并无不妥指出，事实上，记录如果全为二进制数据 0 也是有意义的。</p>
<p>除此之外，lbrdb_model 的库中还提供了一些其他基本的操作，和一些效率不高的搜索和排序操作，而在实际应用时根据具体情况进行扩展和优化。</p>

<p>一般情况下，一个表只提供了 record 和 reflection 两个数据段，实际情况下，数据可能拥有比较复杂的属性，你可以对 record 或者 reflection 的内部结构进行划分实现，也可以向下面这样，多个 block 表相关联实现，lbrdb0 和 lbrdb1 共用记录 ID 并不会造成额外开支，以后我们分析数据结构会知道 ID 实际上是隐含的，不占内存。</p>

<table border="1">
<tr>
<td>lbrdb0</td><td>lbrdb1</td>
</tr>
<tr><td>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>01</td><td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>02</td><td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table></td>
<td><table border="1">
<tr>
<td>record</td><td>reflection</td>
</tr>
<tr>
<td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td>
</tr>
</table>
</td>
</tr>
</table>
<p>谈一下导入和导出表的问题。关于对整个数据表的操作有以下几个基本函数：</p>
<div style="background:#CCC;">
<span>
<span><span class="S5">void</span><span class="S0"> </span>LBRDB_set_head<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
LBRDB<span class="S0"> </span>LBRDB_clone<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_delete<span class="S10">(</span>LBRDB<span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_export<span class="S10">(</span>LBRDB<span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_import<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>filename<span class="S10">);</span></span>
</div>
</span>
<p>LBRDB_set_head 用来命名和重命名一个已经存在的数据表，如果要导出数据表，必须事先给数据表命名。LBRDB_clone ，复制一个已经存在的表，将返回一个新的数据表，你需要有个容器存储复制的数据表，例如<em> LBRDB clone = LBRDB_colne(&lbrdb); </em>，能够得到一个与“lbrdb”相同的复制品“clone”。LBRDB_delete 能够销毁一个已经存在的表，删除数据并且释放内存。LBRDB_export 导出一个表到当前路径，将以表的名字创建新新的目录，并将表导出为 3 个文件：“info”，“memory_pool”，“reflection”。LBRDB_import 则用来导入一个数据表，需要提供参数“filename”，是导入保存数据表导出文件的目录的名字，也是导入数据表的名字，特别需要注意，为了避免内存泄漏 LBRDB_import 的导入对象应该是一个未初始化的空表，如果想要合并数据到已经有数据的表中，不能使用 LBRDB_import 方法，需要其他的实现方式，在此暂不讨论。 </p>
<p>最后，关于如何使用 lbrdb 的问题作出补充说明，你可以编译 lbrdb_model 为动态链接库调用，也可以将 lbrdb_model 直接编译到你的项目中，如果单独把 lbrdb 作为外部数据库访问，需要使用 lbrdb 的扩展代码，这些代码单独列出，不在 lbrdb_model 中，可以使用操作系统管理的共享内存(shared memory)方式或者程序代理使用 socket 进行连接访问。</p>










<meta charset="UTF-8">
<style type="text/css">
.S0 {
	color: #808080;
	font-size: 10pt;
}
.S1 {
	font-family: 'Bitstream Vera Serif';
	color: #007F00;
	font-size: 9pt;
}
.S2 {
	font-family: 'Bitstream Vera Serif';
	color: #007F00;
	font-size: 9pt;
}
.S5 {
	font-weight: bold;
	color: #00007F;
	font-size: 10pt;
}
.S4 {
	color: #007F7F;
	font-size: 10pt;
}
.S6 {
	color: #7F007F;
	font-size: 10pt;
}
.S10 {
	font-weight: bold;
	color: #000000;
	font-size: 10pt;
}
span {
	font-family: 'Bitstream Vera Sans';
	color: #000000;
	font-size: 9pt;
}
</style>

<p>简单的说明 lbrdb - 2017-01-10</p>

<p>lbrdb 并不是专门作为数据库使用而设计的。2015 年时，因为我在写一个 NLP 的程序，在其中使用了一些数据表，后来从中抽取一些代码，作出一定的修改，成为现在的 lbrdb_model 。这只是一个数据模型，你可以直接在此模型的基础上构造新的数据结构，设计更复杂的数据库。在2016 年时，通过独立出来的 lbrdb ，我做了几个简单的例子，比如说 NLP 的关键字筛选工具 lsk ，或者一个简单的 web 应用 PHP chat 。也可以加以扩展使用 lbrdb 作为 blog 或者 BBS 应用的数据库。目前已经为 lbrdb_model 提供了一些简单的工具和扩展。lbrdb_model 的代码使用 ANSI C 编写，可以在任何 32 位以上计算机上编译使用，如果在16位系统上使用一些操作可能是不兼容的。兼容 Windows，Linux 等操作系统，事实上，即使没有操作系统，仍然能够编译和使用 lbrdb_model ，不过如果需要使用文件操作，你需要至少在你的平台上移植文件系统。</p>

<p>因为最初的设计，lbrdb 的应用是比较特殊的，所以代码中存在很多不寻常的操作。例如 compact 表， hash_di32 ，他们事实上就是为了之前 NLP 程序所设计的特殊数据模型。在多数常规的应用中应该不会使用。block 表则是比较常规的实现方式，其中提供了 quick_hash 的哈希方式也是有一些特殊用法的。关于 bug 的问题，因为一些个人原因，并没有很好的处理，大多数函数的实现拥有不错的效率，在此提及一个问题，提供了一个排序函数，使用了 shell sort 的算法实现，这个是某个特殊的约定，你可以把它替换成 quick sort 或者其他更高效的算法。</p>
<p>lbrdb_model 作为基本模块，原则上不提供有针对性的优化和扩展，只提供基本工具和实现的参考。</p>
<p>首先讲 lbrdb 中的 block 模式。这就是一个简单的线性表。表内有两个必要部分，record 和 reflection，ID 是隐含约定的。每条 record 都有与之对应的 reflection 。</p>

<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>01</td><td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>02</td><td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>

<p>可以使用以下函数创建一个 block 表：</p>

<p><em>LBRDB LBRDB_new_database_blockdb(unsigned int blen, unsigned int rf_block,
				 unsigned int nrecord);</em></p>

<p>你需要给出参数 blen ，block 的长度，也就是表中一个 record 的长度；rf_block，是 reflection 的长度；nrecord 设置表中最多能够容纳多少条记录，ID 合法的最大值就是 nrecord - 1。如果在初始化时把 blen 或者 rf_block 设置为 0，将使  record 或 reflection 无效，nreocrd 为 0 时，表是空的。通过分析内存结构，所有的 record 和 reflection 分别在两段连续的内存中，因此，如果不将表卸载，一旦创建了表，它的物理结构是不可调整的，当然，如果你采取一些特殊的算法，可以构造能够动态调整的表，那么它需要由多个表共同实现，在此不讨论。</p>

<p>建立了一张表后，能够使用下面的函数进行操作：</p>
<p>获取 record ，reflection 的指针</p>
<div style="background:#CCC;">
<span>
<span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>LBRDB_get_mem_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><br />
<span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>LBRDB_get_reflection<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><br />
</span>
</div>

<p>你可以使用任何方式操作内存，写入字符串或者二进制数据都是可以的，例如：</p>

<div style="background:#CCC;">
<span><span class="S10">...</span><br />
LBRDB<span class="S0"> </span>lbrdb<span class="S0"> </span><span class="S10">=</span><span class="S0"> </span>LBRDB_new_database_blockdb<span class="S10">(</span><span class="S4">128</span><span class="S10">,</span><span class="S0"> </span><span class="S4">4</span><span class="S10">,</span><span class="S0"> </span><span class="S4">100</span><span class="S10">);</span><br />
sprintf<span class="S10">(</span>LBRDB_get_mem_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"hello world"</span><span class="S10">);</span><br />
sprintf<span class="S10">(</span>LBRDB_get_reflection<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"%d"</span><span class="S10">,</span><span class="S0"> </span><span class="S4">0xff00ee11</span><span class="S10">);</span><br />
strcpy<span class="S10">(</span>LBRDB_get_mem_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">1</span><span class="S10">),</span><span class="S0"> </span><span class="S6">"copy string"</span><span class="S10">);</span></span>
</div>

<p>上述代码段创建了一个 record 长度为 128，reflection 长度为 4 ，容量为 100 的 block 表。习惯上使用 record 保存主要记录，reflection 保存其他信息，多数情况下我习惯将 reflection 设为 4 ，是因为我习惯在 reflection 中保存 32 位指针，事实上 reflection 的使用是自由的，函数库中提供了一些用法保留自之前其他程序中的做法。LBRDB_get_mem_record 和 LBRDB_get_reflection 都要求两个参数，使用 LBRDB* 指向一个已经存在的表，eidc 提供操作目标的 ID 。因为并没有对数据类型作出要求，理论上你可以在内存不溢出的情况下使用任何方式操作记录。如果需要检查边界来避免溢出，record 和 reflection 的长度通过访问 LBRDB::blen 和 LBRDB::rf_block 获得。执行上述代码段后，表内数据情况如下：</p>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>hello world</td><td>0xff00ee11</td>
</tr>
<tr>
<td>01</td><td>copy string</td><td></td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>
<p><em>*ID 0 的 reflection 是 16 进制数 0xff00ee11 在此为了方便表达用字符串写出</em></p>
<p>为了避免直接操作指针，提供一些简单的读写操作：</p>
<div style="background:#CCC;">
<span>
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_reflection<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_mem_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_copy_mem_record_bin<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>length<span class="S10">);</span><br />
<span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_write_mem<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>length<span class="S10">);</span><br />
</span>
</div>
<p>通过 remove_LBRDB_RECORD 可以删除一个记录，LBRDB_swap_blockdb_record将任意两个记录交换位置，成功则返回 0 ，否则返回非 0 状态值。不合法的 ID 或者不适当的数据表会导致操作失败返回非 0 值。</p>
<div style="background:#CCC;">
<span><span class="S5">char</span><span class="S0"> </span>remove_LBRDB_RECORD<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc<span class="S10">);</span><span class="S0">&nbsp; &nbsp; &nbsp;</span><span class="S2">//remove record only for blockdb</span><br /><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_swap_blockdb_record<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc0<span class="S10">,</span><br />
<span class="S0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="S5">unsigned</span><span class="S0"> </span><span class="S5">int</span><span class="S0"> </span>eidc1<span class="S10">);</span><br />
</span>
</div>
<p>在上例的基础下继续执行一下两行代码：</p>
<div style="background:#CCC;">
<span><span class="S10">...</span><br />
LBRDB_swap_blockdb_record<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">,</span><span class="S0"> </span><span class="S4">1</span><span class="S10">);</span><br />
remove_LBRDB_RECORD<span class="S10">(&amp;</span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S4">0</span><span class="S10">);</span></span>
</div>
</br>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td></td><td></td>
</tr>
<tr>
<td>01</td><td>hello world</td><td>0xff00ee11</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table>
<p>首先交换表 lbrdb 中 ID 是 0 和 1 的两个记录，之后删除 ID 是 0 的记录。注意，LBRDB_swap_blockdb_record 是实实在在的通过操作内存交换了两个记录，而不是操作指针或者重新映射的方式，因此你可以直接利用此函数对表进行排序操作。remove_LBRDB_RECORD 的删除操作是不可回溯的，会清空记录的所有内容(即将内存重置为 0)。两个函数都只能用于 block 表，ID 在初始化时设置的表的容量范围内都是合法的，无论是交换两个记录还是删除某个记录，函数都不检查记录是否是空的，这么做并无不妥指出，事实上，记录如果全为二进制数据 0 也是有意义的。</p>
<p>除此之外，lbrdb_model 的库中还提供了一些其他基本的操作，和一些效率不高的搜索和排序操作，而在实际应用时根据具体情况进行扩展和优化。</p>

<p>一般情况下，一个表只提供了 record 和 reflection 两个数据段，实际情况下，数据可能拥有比较复杂的属性，你可以对 record 或者 reflection 的内部结构进行划分实现，也可以向下面这样，多个 block 表相关联实现，lbrdb0 和 lbrdb1 共用记录 ID 并不会造成额外开支，以后我们分析数据结构会知道 ID 实际上是隐含的，不占内存。</p>

<table border="1">
<tr>
<td>lbrdb0</td><td>lbrdb1</td>
</tr>
<tr><td>
<table border="1">
<tr>
<td>ID</td><td>record</td><td>reflection</td>
</tr>
<tr>
<td>00</td><td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>01</td><td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>02</td><td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td>
</tr>
</table></td>
<td><table border="1">
<tr>
<td>record</td><td>reflection</td>
</tr>
<tr>
<td>REC00</td><td>REF00</td>
</tr>
<tr>
<td>REC01</td><td>REF01</td>
</tr>
<tr>
<td>REC02</td><td>REF02</td>
</tr>
<tr>
<td>...</td><td>...</td>
</tr>
</table>
</td>
</tr>
</table>
<p>谈一下导入和导出表的问题。关于对整个数据表的操作有以下几个基本函数：</p>
<div style="background:#CCC;">
<span>
<span><span class="S5">void</span><span class="S0"> </span>LBRDB_set_head<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>str<span class="S10">);</span><br />
LBRDB<span class="S0"> </span>LBRDB_clone<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_delete<span class="S10">(</span>LBRDB<span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">void</span><span class="S0"> </span>LBRDB_export<span class="S10">(</span>LBRDB<span class="S0"> </span>lbrdb<span class="S10">);</span><br />
<span class="S5">unsigned</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span>LBRDB_import<span class="S10">(</span>LBRDB<span class="S0"> </span><span class="S10">*</span><span class="S0"> </span>lbrdb<span class="S10">,</span><span class="S0"> </span><span class="S5">char</span><span class="S0"> </span><span class="S10">*</span>filename<span class="S10">);</span></span>
</div>
</span>
<p>LBRDB_set_head 用来命名和重命名一个已经存在的数据表，如果要导出数据表，必须事先给数据表命名。LBRDB_clone ，复制一个已经存在的表，将返回一个新的数据表，你需要有个容器存储复制的数据表，例如<em> LBRDB clone = LBRDB_colne(&lbrdb); </em>，能够得到一个与“lbrdb”相同的复制品“clone”。LBRDB_delete 能够销毁一个已经存在的表，删除数据并且释放内存。LBRDB_export 导出一个表到当前路径，将以表的名字创建新新的目录，并将表导出为 3 个文件：“info”，“memory_pool”，“reflection”。LBRDB_import 则用来导入一个数据表，需要提供参数“filename”，是导入保存数据表导出文件的目录的名字，也是导入数据表的名字，特别需要注意，为了避免内存泄漏 LBRDB_import 的导入对象应该是一个未初始化的空表，如果想要合并数据到已经有数据的表中，不能使用 LBRDB_import 方法，需要其他的实现方式，在此暂不讨论。 </p>
<p>最后，关于如何使用 lbrdb 的问题作出补充说明，你可以编译 lbrdb_model 为动态链接库调用，也可以将 lbrdb_model 直接编译到你的项目中，如果单独把 lbrdb 作为外部数据库访问，需要使用 lbrdb 的扩展代码，这些代码单独列出，不在 lbrdb_model 中，可以使用操作系统管理的共享内存(shared memory)方式或者程序代理使用 socket 进行连接访问。</p>











